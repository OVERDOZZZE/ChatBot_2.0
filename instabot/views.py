from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
from decouple import config
from django.http import HttpResponse, JsonResponse
import json
import requests
import re
from openai import OpenAI
from .models import InstaBotMessage, Product, ConversationSession, Purchase
from django.utils import timezone
from datetime import timedelta
import logging
import time
from groq import Groq

# Set up logging
logger = logging.getLogger(__name__)

VERIFY_TOKEN = config('VERIFY_TOKEN')
LONG_USER_ACCESS_TOKEN = config('LONG_USER_ACCESS_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')
BOT_ID = config('BOT_ID')
MAX_HISTORY_LENGTH = 10
OPENAI_API_MODEL = config('OPENAI_API_MODEL')

# AI API health tracking
AI_API_LAST_SUCCESS = None
AI_API_FAILURE_COUNT = 0
AI_API_MAX_FAILURES = 3
AI_API_TIMEOUT = 10

# client = OpenAI(
#     base_url=config('BASE_OPENAI_API_URL'),
#     api_key=OPENAI_API_KEY,
# )

client = Groq(
    api_key=config("OPENAI_API_KEY"),
)

def get_intent_prompt():
    return """–û–ø—Ä–µ–¥–µ–ª–∏ –Ω–∞–º–µ—Ä–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ –∏–∑ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è. –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–º–µ—Ä–µ–Ω–∏—è:
- –ü–û–ö–£–ü–ö–ê: —Ö–æ—á–µ—Ç –∫—É–ø–∏—Ç—å —Ç–æ–≤–∞—Ä, –¥–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ—Ä–∑–∏–Ω—É, –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑
- –ö–ê–¢–ê–õ–û–ì: —Ö–æ—á–µ—Ç –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–æ–≤–∞—Ä—ã, —É–∑–Ω–∞—Ç—å —á—Ç–æ –µ—Å—Ç—å –≤ –Ω–∞–ª–∏—á–∏–∏
- –ò–ù–§–û–†–ú–ê–¶–ò–Ø: –≤–æ–ø—Ä–æ—Å—ã –æ —Ç–æ–≤–∞—Ä–µ, —Ü–µ–Ω–µ, –¥–æ—Å—Ç–∞–≤–∫–µ
- –ñ–ê–õ–û–ë–ê: –Ω–µ–¥–æ–≤–æ–ª–µ–Ω —Ç–æ–≤–∞—Ä–æ–º –∏–ª–∏ —Å–µ—Ä–≤–∏—Å–æ–º
- –ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨: –±–ª–∞–≥–æ–¥–∞—Ä–∏—Ç –∑–∞ –∑–∞–∫–∞–∑ –∏–ª–∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ
- –ü–†–û–ß–ï–ï: –æ–±—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã, –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ

–û—Ç–≤–µ—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º: –ü–û–ö–£–ü–ö–ê, –ö–ê–¢–ê–õ–û–ì, –ò–ù–§–û–†–ú–ê–¶–ò–Ø, –ñ–ê–õ–û–ë–ê, –ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨ –∏–ª–∏ –ü–†–û–ß–ï–ï."""


def get_system_prompt_by_state(state, session=None):
    prompts = {
        'idle': """–¢—ã ‚Äî –≤–µ–∂–ª–∏–≤—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –º–∞–≥–∞–∑–∏–Ω–∞ —Ç—Ä–∏–º–º–µ—Ä–æ–≤ –∏ —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è –ø–∞—Ä–∏–∫–º–∞—Ö–µ—Ä–æ–≤ –≤ –ë–∏—à–∫–µ–∫–µ. 
–û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É. –î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –ë–∏—à–∫–µ–∫—É –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è. 
–ü—Ä–µ–¥–ª–æ–∂–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞—Ç–∞–ª–æ–≥ –∏–ª–∏ –ø–æ–º–æ–≥–∏ —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏. –ï—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –Ω–µ–¥–∞–≤–Ω–æ —Å–¥–µ–ª–∞–ª –∑–∞–∫–∞–∑, 
–ø–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –µ–≥–æ –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ø–æ–º–æ—â—å.""",

        'browsing': """–¢—ã –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å –∫–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤. –ü—Ä–µ–¥–æ—Å—Ç–∞–≤—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–æ–≤–∞—Ä–∞—Ö 
–∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –ü–æ–º–æ–≥–∏ –∫–ª–∏–µ–Ω—Ç—É –≤—ã–±—Ä–∞—Ç—å —Ç–æ–≤–∞—Ä –∏ –¥–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ—Ä–∑–∏–Ω—É.""",

        'purchase_product_selection': """–ö–ª–∏–µ–Ω—Ç –¥–æ–±–∞–≤–ª—è–µ—Ç —Ç–æ–≤–∞—Ä—ã –≤ –∫–æ—Ä–∑–∏–Ω—É. –ü–æ–º–æ–≥–∏ –≤—ã–±—Ä–∞—Ç—å —Ç–æ–≤–∞—Ä—ã, 
–ø–æ–∫–∞–∑—ã–≤–∞–π —Ü–µ–Ω—ã –∏ –Ω–∞–ª–∏—á–∏–µ. –ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ –ø—Ä–µ–¥–ª–æ–∂–∏ –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑.""",

        'purchase_collecting_phone': """–°–æ–±–µ—Ä–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è –∑–∞–∫–∞–∑–∞. 
–û–±—ä—è—Å–Ω–∏, —á—Ç–æ –Ω–æ–º–µ—Ä –Ω—É–∂–µ–Ω –¥–ª—è —Å–≤—è–∑–∏ –ø–æ –¥–æ—Å—Ç–∞–≤–∫–µ. –ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ –Ω–æ–º–µ—Ä –≤–≤–µ–¥–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.""",

        'purchase_collecting_address': """–°–æ–±–µ—Ä–∏ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏. –£—Ç–æ—á–Ω–∏ —Ç–æ—á–Ω—ã–π –∞–¥—Ä–µ—Å –≤ –ë–∏—à–∫–µ–∫–µ 
–¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏.""",

        'purchase_confirmation': """–ü–æ–∫–∞–∂–∏ –∏—Ç–æ–≥–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∫–∞–∑–µ: —Ç–æ–≤–∞—Ä—ã, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, 
–æ–±—â—É—é —Å—É–º–º—É, –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏. –ü–æ–ø—Ä–æ—Å–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–∫–∞–∑ —Å–ª–æ–≤–æ–º '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å'.""",

        'complaint': """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π –∂–∞–ª–æ–±—É –∫–ª–∏–µ–Ω—Ç–∞ –≤–µ–∂–ª–∏–≤–æ –∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ. 
–ò–∑–≤–∏–Ω–∏—Å—å –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã.""",

        'inquiry': """–û—Ç–≤–µ—á–∞–π –Ω–∞ –æ–±—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –æ —Ç–æ–≤–∞—Ä–∞—Ö, –¥–æ—Å—Ç–∞–≤–∫–µ, –æ–ø–ª–∞—Ç–µ. 
–ë—É–¥—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–º –Ω–æ –∫—Ä–∞—Ç–∫–∏–º.""",

        'post_purchase': """–ö–ª–∏–µ–Ω—Ç —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–¥–µ–ª–∞–ª –∑–∞–∫–∞–∑. –û—Ç–≤–µ—á–∞–π –¥—Ä—É–∂–µ–ª—é–±–Ω–æ, 
–ø—Ä–µ–¥–ª–∞–≥–∞–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ø–æ–º–æ—â—å –∏–ª–∏ —Ç–æ–≤–∞—Ä—ã. –ù–∞–ø–æ–º–Ω–∏ –æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–≤—è–∑–∞—Ç—å—Å—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏."""
    }

    base_prompt = prompts.get(state, prompts['idle'])

    if session and session.get_selected_products():
        cart_info = f"\n–¢–µ–∫—É—â–∞—è –∫–æ—Ä–∑–∏–Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞: {format_cart(session)}"
        base_prompt += cart_info

    return base_prompt


def format_cart(session):
    """Format cart contents for display"""
    products = session.get_selected_products()
    if not products:
        return "–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞"

    cart_text = []
    total = 0

    for item in products:
        try:
            product = Product.objects.get(id=item['product_id'])
            quantity = item['quantity']
            subtotal = product.price * quantity
            total += subtotal
            cart_text.append(f"‚Ä¢ {product.name} x{quantity} = {subtotal} —Å–æ–º")
        except Product.DoesNotExist:
            continue

    cart_text.append(f"\n–ò—Ç–æ–≥–æ: {total} —Å–æ–º")
    return "\n".join(cart_text)


def format_product_catalog():
    """Format available products for display"""
    products = Product.objects.filter(available=True)
    if not products:
        return "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ç–æ–≤–∞—Ä–æ–≤ –Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏."

    catalog_text = ["üìã –ù–∞—à–∏ —Ç–æ–≤–∞—Ä—ã:\n"]

    for product in products:
        catalog_text.append(f"üîπ {product.name}")
        catalog_text.append(f"   –¶–µ–Ω–∞: {product.price} —Å–æ–º")
        catalog_text.append(f"   {product.description}\n")

    catalog_text.append("–î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –ë–∏—à–∫–µ–∫—É –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è! üöö")
    return "\n".join(catalog_text)


def extract_product_from_message(message):
    """Extract product selection from user message"""
    # Try to find product by name (case insensitive)
    products = Product.objects.filter(available=True)

    for product in products:
        if product.name.lower() in message.lower():
            # Try to extract quantity
            quantity_match = re.search(r'(\d+)\s*—à—Ç|(\d+)\s*—à—Ç—É–∫|(\d+)\s*—à—Ç—É–∫–∏', message.lower())
            quantity = 1
            if quantity_match:
                quantity = int(quantity_match.group(1) or quantity_match.group(2) or quantity_match.group(3))

            return product.id, quantity

    return None, None


def check_ai_api_health():
    """Check if AI API is responding"""
    global AI_API_LAST_SUCCESS, AI_API_FAILURE_COUNT

    try:
        # Simple test request
        completion = client.chat.completions.create(
            model=OPENAI_API_MODEL,
            messages=[
                {"role": "system", "content": "–û—Ç–≤–µ—Ç—å 'OK'"},
                {"role": "user", "content": "—Ç–µ—Å—Ç"}
            ],
            timeout=5,
            max_tokens=10
        )

        if completion.choices[0].message.content:
            AI_API_LAST_SUCCESS = time.time()
            AI_API_FAILURE_COUNT = 0
            return True

    except Exception as e:
        logger.error(f"AI API health check failed: {str(e)}")
        AI_API_FAILURE_COUNT += 1
        return False

    return False


def is_ai_api_healthy():
    """Check if AI API is considered healthy"""
    global AI_API_FAILURE_COUNT, AI_API_LAST_SUCCESS

    # If too many recent failures, consider unhealthy
    if AI_API_FAILURE_COUNT >= AI_API_MAX_FAILURES:
        return False

    # If last success was more than 5 minutes ago, do a health check
    if AI_API_LAST_SUCCESS is None or (time.time() - AI_API_LAST_SUCCESS) > 300:
        return check_ai_api_health()

    return True


def get_fallback_response(state, user_message):
    """Get fallback response when AI API is not working"""

    fallback_responses = {
        'idle': """–ü—Ä–∏–≤–µ—Ç! –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –Ω–∞—Å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Å AI, –Ω–æ —è –≤—Å–µ —Ä–∞–≤–Ω–æ –º–æ–≥—É –ø–æ–º–æ—á—å:

‚Ä¢ –ù–∞–ø–∏—Å–∞—Ç—å '–∫–∞—Ç–∞–ª–æ–≥' - –ø–æ–∫–∞–∂—É –≤—Å–µ —Ç–æ–≤–∞—Ä—ã
‚Ä¢ –ù–∞–ø–∏—Å–∞—Ç—å '–∫—É–ø–∏—Ç—å [–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞]' - –æ—Ñ–æ—Ä–º–ª—é –∑–∞–∫–∞–∑
‚Ä¢ –ù–∞–ø–∏—Å–∞—Ç—å '–ø–æ–º–æ—â—å' - –ø–æ–∫–∞–∂—É –∫–æ–º–∞–Ω–¥—ã

–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?""",

        'browsing': f"–í–æ—Ç –Ω–∞—à –∫–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤:\n\n{format_product_catalog()}\n\n–î–ª—è –∑–∞–∫–∞–∑–∞ –Ω–∞–ø–∏—à–∏—Ç–µ: –∫—É–ø–∏—Ç—å [–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞]",

        'purchase_product_selection': f"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞:\n\n{format_product_catalog()}\n\n–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –∫—É–ø–∏—Ç—å.",

        'post_purchase': """–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –∑–∞–∫–∞–∑! 

–ú–æ–≥—É –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å:
‚Ä¢ '–∫–∞—Ç–∞–ª–æ–≥' - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥—Ä—É–≥–∏–µ —Ç–æ–≤–∞—Ä—ã
‚Ä¢ '–ø–æ–º–æ—â—å' - —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥
‚Ä¢ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –æ –¥–æ—Å—Ç–∞–≤–∫–µ

–ß–µ–º –µ—â–µ –ø–æ–º–æ—á—å?""",

        'complaint': "–ü–æ–Ω–∏–º–∞—é –≤–∞—à–µ –Ω–µ–¥–æ–≤–æ–ª—å—Å—Ç–≤–æ. –ú—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–±–µ—Ä–µ–º —Å–∏—Ç—É–∞—Ü–∏—é. –ú–æ–∂–µ—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å —Å–≤–æ–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã, –∏ –º—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã.",

        'inquiry': """–û—Ç–≤–µ—á—É –Ω–∞ –æ—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã:

‚Ä¢ –î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –ë–∏—à–∫–µ–∫—É - –ë–ï–°–ü–õ–ê–¢–ù–û
‚Ä¢ –û–ø–ª–∞—Ç–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏
‚Ä¢ –ì–∞—Ä–∞–Ω—Ç–∏—è –Ω–∞ –≤—Å–µ —Ç–æ–≤–∞—Ä—ã
‚Ä¢ –†–∞–±–æ—Ç–∞–µ–º –µ–∂–µ–¥–Ω–µ–≤–Ω–æ

–ù—É–∂–Ω–∞ –¥—Ä—É–≥–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è?"""
    }

    return fallback_responses.get(state, fallback_responses['idle'])
    """Extract phone number from message"""
    # Look for phone patterns
    phone_patterns = [
        r'\+996\s*\d{3}\s*\d{3}\s*\d{3}',
        r'0\d{3}\s*\d{3}\s*\d{3}',
        r'\d{3}\s*\d{3}\s*\d{3}'
    ]

    for pattern in phone_patterns:
        match = re.search(pattern, message)
        if match:
            return match.group().replace(' ', '')

    return None


def has_recent_purchase(sender_id, hours=2):
    """Check if user made a purchase recently"""
    time_threshold = timezone.now() - timedelta(hours=hours)
    return Purchase.objects.filter(
        sender_id=sender_id,
        timestamp__gte=time_threshold
    ).exists()


@csrf_exempt
def webhook(request):
    if request.method == 'GET':
        verify_token = request.GET.get('hub.verify_token')
        challenge = request.GET.get('hub.challenge')
        if verify_token == VERIFY_TOKEN:
            return HttpResponse(challenge)
        else:
            return HttpResponse('Invalid Verification Token', status=403)

    elif request.method == 'POST':
        try:
            data = json.loads(request.body)
            for entry in data.get("entry", []):
                if 'messaging' in entry:
                    process_message(entry['messaging'])
                elif 'comments' in entry:
                    process_comment(entry['comments'])
                elif 'mention' in entry:
                    process_mention(entry['mention'])

            return JsonResponse({"status": "Event processed"})

        except Exception as e:
            logger.error(f"Webhook error: {str(e)}")
            return JsonResponse({"error": str(e)}, status=400)


def privacy_policy(request):
    return render(request, 'privacy_policy.html')


def home_page(request):
    return render(request, 'home.html')


def process_message(data):
    for event in data:
        message = event.get("message", {})
        sender_id = event.get("sender", {}).get("id")

        if sender_id == BOT_ID:
            continue

        text = message.get("text")
        if not text:
            continue

        try:
            # Clean up old messages
            expiry = timezone.now() - timedelta(hours=24)
            InstaBotMessage.objects.filter(sender_id=sender_id, timestamp__lt=expiry).delete()

            # Save user message
            InstaBotMessage.objects.create(
                sender_id=sender_id,
                role="user",
                content=text
            )

            # Get or create session
            session, created = ConversationSession.objects.get_or_create(
                sender_id=sender_id,
                defaults={'current_state': 'idle'}
            )

            # Process message based on current state
            reply = handle_conversation_flow(session, text)

            # Save bot response
            InstaBotMessage.objects.create(
                sender_id=sender_id,
                role="assistant",
                content=reply
            )

            send_message(reply, str(sender_id))

        except Exception as e:
            logger.error(f"Error processing message from {sender_id}: {str(e)}")
            # Send fallback message
            fallback_message = "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø–æ–º–æ—â—å' –¥–ª—è –Ω–∞—á–∞–ª–∞."
            send_message(fallback_message, str(sender_id))


def handle_conversation_flow(session, user_message):
    """Main conversation flow handler"""

    try:
        # Check for confirmation word first
        if user_message.strip().lower() == "–ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å" and session.current_state == 'purchase_confirmation':
            return handle_purchase_confirmation(session, user_message)

        # Check for reset commands
        if user_message.lower() in ['–ø–æ–º–æ—â—å', '–Ω–∞—á–∞—Ç—å', '—Å—Ç–∞—Ä—Ç', 'reset']:
            session.reset_session()
            return "–ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ—â–Ω–∏–∫ –º–∞–≥–∞–∑–∏–Ω–∞ —Ç—Ä–∏–º–º–µ—Ä–æ–≤ –∏ —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è –ø–∞—Ä–∏–∫–º–∞—Ö–µ—Ä–æ–≤. –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?\n\n‚Ä¢ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞—Ç–∞–ª–æ–≥\n‚Ä¢ –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑\n‚Ä¢ –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å"

        # Handle different states
        if session.current_state == 'idle':
            return handle_idle_state(session, user_message)

        elif session.current_state == 'browsing':
            return handle_browsing_state(session, user_message)

        elif session.current_state == 'purchase_product_selection':
            return handle_product_selection_state(session, user_message)

        elif session.current_state == 'purchase_collecting_phone':
            return handle_phone_collection_state(session, user_message)

        elif session.current_state == 'purchase_collecting_address':
            return handle_address_collection_state(session, user_message)

        elif session.current_state == 'purchase_confirmation':
            return handle_confirmation_state(session, user_message)

        elif session.current_state == 'complaint':
            return handle_complaint_state(session, user_message)

        elif session.current_state == 'inquiry':
            return handle_inquiry_state(session, user_message)

        elif session.current_state == 'post_purchase':
            return handle_post_purchase_state(session, user_message)

        else:
            session.reset_session()
            return "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ù–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞. –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?"

    except Exception as e:
        logger.error(f"Error in conversation flow for {session.sender_id}: {str(e)}")
        session.reset_session()
        return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞. –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?"


def handle_idle_state(session, user_message):
    """Handle messages when bot is in idle state"""

    try:
        # Check if user recently made a purchase
        if has_recent_purchase(session.sender_id):
            session.current_state = 'post_purchase'
            session.save()
            return handle_post_purchase_state(session, user_message)

        # Classify intent using AI
        intent = classify_intent(user_message)

        if intent == '–ö–ê–¢–ê–õ–û–ì':
            session.current_state = 'browsing'
            session.save()
            return f"üìã –í–æ—Ç –Ω–∞—à –∫–∞—Ç–∞–ª–æ–≥:\n\n{format_product_catalog()}\n\n–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?"

        elif intent == '–ü–û–ö–£–ü–ö–ê':
            session.current_state = 'purchase_product_selection'
            session.save()
            return f"–û—Ç–ª–∏—á–Ω–æ! –î–∞–≤–∞–π—Ç–µ –≤—ã–±–µ—Ä–µ–º —Ç–æ–≤–∞—Ä—ã:\n\n{format_product_catalog()}\n\n–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –∫—É–ø–∏—Ç—å."

        elif intent == '–ò–ù–§–û–†–ú–ê–¶–ò–Ø':
            session.current_state = 'inquiry'
            session.save()
            return generate_ai_response(session, user_message)

        elif intent == '–ñ–ê–õ–û–ë–ê':
            session.current_state = 'complaint'
            session.save()
            return "–ú–Ω–µ –æ—á–µ–Ω—å –∂–∞–ª—å, —á—Ç–æ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã. –†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ, —á—Ç–æ —Å–ª—É—á–∏–ª–æ—Å—å, –∏ —è –ø–æ—Å—Ç–∞—Ä–∞—é—Å—å –ø–æ–º–æ—á—å."

        elif intent == '–ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨':
            return "–°–ø–∞—Å–∏–±–æ –±–æ–ª—å—à–æ–µ! –†–∞–¥—ã –±—ã–ª–∏ –≤–∞–º –ø–æ–º–æ—á—å. –ï—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —á—Ç–æ-—Ç–æ –µ—â–µ, –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å! üòä"

        else:
            return generate_ai_response(session, user_message)

    except Exception as e:
        logger.error(f"Error in idle state for {session.sender_id}: {str(e)}")
        return "–ü—Ä–∏–≤–µ—Ç! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å? –ú–æ–≥—É –ø–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤ –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã."


def handle_post_purchase_state(session, user_message):
    """Handle messages after recent purchase"""

    try:
        # Check for new purchase intent
        if any(word in user_message.lower() for word in ['–∫—É–ø–∏—Ç—å', '–∑–∞–∫–∞–∑–∞—Ç—å', '–µ—â–µ', '—Ç–∞–∫–∂–µ', '—Ç–æ–∂–µ']):
            session.current_state = 'purchase_product_selection'
            session.save()
            return f"–ö–æ–Ω–µ—á–Ω–æ! –í–æ—Ç –Ω–∞—à –∫–∞—Ç–∞–ª–æ–≥:\n\n{format_product_catalog()}\n\n–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫ –∑–∞–∫–∞–∑—É?"

        # Check for catalog request
        if any(word in user_message.lower() for word in ['–∫–∞—Ç–∞–ª–æ–≥', '—Ç–æ–≤–∞—Ä—ã', '—á—Ç–æ –µ—Å—Ç—å']):
            session.current_state = 'browsing'
            session.save()
            return f"üìã –ù–∞—à –∫–∞—Ç–∞–ª–æ–≥:\n\n{format_product_catalog()}"

        # Default response for post-purchase
        session.current_state = 'idle'
        session.save()

        response = generate_ai_response(session, user_message)
        if not response:
            response = get_fallback_response(session.current_state, user_message)

        return response

    except Exception as e:
        logger.error(f"Error in post-purchase state for {session.sender_id}: {str(e)}")
        session.current_state = 'idle'
        session.save()
        return "–°–ø–∞—Å–∏–±–æ –∑–∞ –∑–∞–∫–∞–∑! –ß–µ–º –µ—â–µ –º–æ–≥—É –ø–æ–º–æ—á—å?"


def handle_browsing_state(session, user_message):
    """Handle browsing catalog state"""

    try:
        # Check if user wants to buy something
        if any(word in user_message.lower() for word in ['–∫—É–ø–∏—Ç—å', '–∑–∞–∫–∞–∑–∞—Ç—å', '—Ö–æ—á—É', '–≤–æ–∑—å–º—É']):
            session.current_state = 'purchase_product_selection'
            session.save()
            return "–û—Ç–ª–∏—á–Ω–æ! –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –∫—É–ø–∏—Ç—å."

        return generate_ai_response(session, user_message)

    except Exception as e:
        logger.error(f"Error in browsing state for {session.sender_id}: {str(e)}")
        return f"–í–æ—Ç –Ω–∞—à –∫–∞—Ç–∞–ª–æ–≥:\n\n{format_product_catalog()}\n\n–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?"


def handle_product_selection_state(session, user_message):
    """Handle product selection for purchase"""

    try:
        # Check for product in message
        product_id, quantity = extract_product_from_message(user_message)

        if product_id:
            session.add_product(product_id, quantity)
            session.save()

            product = Product.objects.get(id=product_id)
            response = f"‚úÖ –î–æ–±–∞–≤–∏–ª –≤ –∫–æ—Ä–∑–∏–Ω—É: {product.name} x{quantity}\n\n"
            response += f"–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞:\n{format_cart(session)}\n\n"
            response += "–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ—â–µ —Ç–æ–≤–∞—Ä—ã –∏–ª–∏ –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑?"
            return response

        # Check if wants to proceed to order
        if any(word in user_message.lower() for word in ['–∑–∞–∫–∞–∑', '–æ—Ñ–æ—Ä–º–∏—Ç—å', '–∫—É–ø–∏—Ç—å', '—Ö–≤–∞—Ç–∏—Ç', '–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ']):
            if session.get_selected_products():
                session.current_state = 'purchase_collecting_phone'
                session.save()
                return f"–û—Ç–ª–∏—á–Ω–æ! –í–∞—à–∏ —Ç–æ–≤–∞—Ä—ã:\n{format_cart(session)}\n\n–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ –Ω—É–∂–µ–Ω –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:"
            else:
                return "–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞. –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä—ã –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞."

        return f"–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ –Ω–∞—à–µ–ª —Ç–∞–∫–æ–π —Ç–æ–≤–∞—Ä. –í–æ—Ç —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å:\n\n{format_product_catalog()}"

    except Exception as e:
        logger.error(f"Error in product selection for {session.sender_id}: {str(e)}")
        return f"–î–∞–≤–∞–π—Ç–µ –≤—ã–±–µ—Ä–µ–º —Ç–æ–≤–∞—Ä:\n\n{format_product_catalog()}"


def handle_phone_collection_state(session, user_message):
    """Handle phone number collection"""

    try:
        phone = extract_phone_from_message(user_message)

        if phone:
            session.collected_phone = phone
            session.current_state = 'purchase_collecting_address'
            session.save()
            return "–°–ø–∞—Å–∏–±–æ! –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ –ë–∏—à–∫–µ–∫–µ:"

        return "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: +996 555 123 456 –∏–ª–∏ 0555 123 456):"

    except Exception as e:
        logger.error(f"Error in phone collection for {session.sender_id}: {str(e)}")
        return "–£–∫–∞–∂–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è —Å–≤—è–∑–∏:"


def handle_address_collection_state(session, user_message):
    """Handle address collection"""

    try:
        if len(user_message.strip()) > 10:  # Basic validation
            session.collected_address = user_message.strip()
            session.current_state = 'purchase_confirmation'
            session.save()

            # Prepare order summary
            products_info = []
            total = 0

            for item in session.get_selected_products():
                try:
                    product = Product.objects.get(id=item['product_id'])
                    quantity = item['quantity']
                    subtotal = product.price * quantity
                    total += subtotal
                    products_info.append(f"‚Ä¢ {product.name} x{quantity} = {subtotal} —Å–æ–º")
                except Product.DoesNotExist:
                    continue

            summary = f"üìã –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞:\n\n"
            summary += "\n".join(products_info)
            summary += f"\n\n–ò—Ç–æ–≥–æ: {total} —Å–æ–º"
            summary += f"\n–¢–µ–ª–µ—Ñ–æ–Ω: {session.collected_phone}"
            summary += f"\n–ê–¥—Ä–µ—Å: {session.collected_address}"
            summary += f"\n–î–æ—Å—Ç–∞–≤–∫–∞: –ë–ï–°–ü–õ–ê–¢–ù–û"
            summary += f"\n\n‚úÖ –î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ –Ω–∞–ø–∏—à–∏—Ç–µ: –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å"

            return summary

        return "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:"

    except Exception as e:
        logger.error(f"Error in address collection for {session.sender_id}: {str(e)}")
        return "–£–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ –ë–∏—à–∫–µ–∫–µ:"


def handle_confirmation_state(session, user_message):
    """Handle order confirmation"""

    if user_message.strip().lower() != "–ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å":
        return "–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ –Ω–∞–ø–∏—à–∏—Ç–µ —Ç–æ—á–Ω–æ: –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å"

    return handle_purchase_confirmation(session, user_message)


def handle_purchase_confirmation(session, user_message):
    """Process confirmed purchase"""

    try:
        # Prepare products data for Purchase model
        products_data = []
        total_amount = 0

        for item in session.get_selected_products():
            try:
                product = Product.objects.get(id=item['product_id'])
                quantity = item['quantity']
                subtotal = product.price * quantity
                total_amount += subtotal

                products_data.append({
                    'product_id': product.id,
                    'product_name': product.name,
                    'quantity': quantity,
                    'price': float(product.price),
                    'subtotal': float(subtotal)
                })
            except Product.DoesNotExist:
                continue

        # Create purchase record
        purchase = Purchase.objects.create(
            sender_id=session.sender_id,
            phone_number=session.collected_phone,
            address=session.collected_address,
            customer_last_message=user_message,
            total_amount=total_amount
        )
        purchase.set_products_data(products_data)
        purchase.save()

        # Set to post-purchase state instead of completely resetting
        session.current_state = 'post_purchase'
        session.selected_products = None
        session.collected_phone = None
        session.collected_address = None
        session.save()

        response = f"üéâ –ó–∞–∫–∞–∑ ‚Ññ{purchase.id} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!\n\n"
        response += f"–ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É {purchase.phone_number} –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –¥–æ—Å—Ç–∞–≤–∫–∏.\n\n"
        response += f"–î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –∞–¥—Ä–µ—Å—É: {purchase.address}\n"
        response += f"–°—É–º–º–∞ –∑–∞–∫–∞–∑–∞: {total_amount} —Å–æ–º\n"
        response += f"–î–æ—Å—Ç–∞–≤–∫–∞: –ë–ï–°–ü–õ–ê–¢–ù–û\n\n"
        response += "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É! üòä\n\n"
        response += "–ù—É–∂–Ω–æ —á—Ç–æ-—Ç–æ –µ—â–µ?"

        return response

    except Exception as e:
        logger.error(f"Error in purchase confirmation for {session.sender_id}: {str(e)}")
        return f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ –Ω–∞–ø—Ä—è–º—É—é."


def handle_complaint_state(session, user_message):
    """Handle customer complaints"""

    try:
        session.current_state = 'idle'
        session.save()

        response = generate_ai_response(session, user_message)
        if not response:
            response = get_fallback_response('complaint', user_message)

        response += "\n\n–í–∞—à–∞ –∂–∞–ª–æ–±–∞ –ø—Ä–∏–Ω—è—Ç–∞. –ú—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–±–µ—Ä–µ–º —Å–∏—Ç—É–∞—Ü–∏—é."
        return response

    except Exception as e:
        logger.error(f"Error handling complaint for {session.sender_id}: {str(e)}")
        return "–ú–Ω–µ –æ—á–µ–Ω—å –∂–∞–ª—å, —á—Ç–æ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã. –ú—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–±–µ—Ä–µ–º —Å–∏—Ç—É–∞—Ü–∏—é."


def handle_inquiry_state(session, user_message):
    """Handle general inquiries"""

    try:
        session.current_state = 'idle'
        session.save()

        response = generate_ai_response(session, user_message)
        if not response:
            response = get_fallback_response('inquiry', user_message)

        return response

    except Exception as e:
        logger.error(f"Error handling inquiry for {session.sender_id}: {str(e)}")
        return "–ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å? –ú–æ–≥—É –ø–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤ –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã."


def classify_intent(user_message):
    """Classify user intent using AI with fallback"""
    global AI_API_FAILURE_COUNT

    # Simple keyword-based fallback classification
    message_lower = user_message.lower()

    # Check for purchase intent
    if any(word in message_lower for word in ['–∫—É–ø–∏—Ç—å', '–∑–∞–∫–∞–∑–∞—Ç—å', '—Ö–æ—á—É', '–≤–æ–∑—å–º—É', '–æ—Ñ–æ—Ä–º–∏—Ç—å']):
        return '–ü–û–ö–£–ü–ö–ê'

    # Check for catalog intent
    if any(word in message_lower for word in ['–∫–∞—Ç–∞–ª–æ–≥', '—Ç–æ–≤–∞—Ä—ã', '—á—Ç–æ –µ—Å—Ç—å', '–ø–æ–∫–∞–∑–∞—Ç—å', '–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å']):
        return '–ö–ê–¢–ê–õ–û–ì'

    # Check for complaints
    if any(word in message_lower for word in ['–∂–∞–ª–æ–±–∞', '–ø–ª–æ—Ö–æ', '–Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç', '–Ω–µ–¥–æ–≤–æ–ª–µ–Ω', '–ø—Ä–æ–±–ª–µ–º–∞']):
        return '–ñ–ê–õ–û–ë–ê'

    # Check for gratitude
    if any(word in message_lower for word in ['—Å–ø–∞—Å–∏–±–æ', '–±–ª–∞–≥–æ–¥–∞—Ä—é', '–æ—Ç–ª–∏—á–Ω–æ', '—Ö–æ—Ä–æ—à–æ']):
        return '–ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨'

    # Try AI classification if API is healthy
    if is_ai_api_healthy():
        try:
            completion = client.chat.completions.create(
                model="google/gemma-3n-e4b-it",
                messages=[
                    {"role": "system", "content": get_intent_prompt()},
                    {"role": "user", "content": user_message}
                ],
                timeout=AI_API_TIMEOUT,
                max_tokens=20
            )

            intent = completion.choices[0].message.content.strip().upper()

            # Reset failure count on success
            AI_API_FAILURE_COUNT = 0
            global AI_API_LAST_SUCCESS
            AI_API_LAST_SUCCESS = time.time()

            if intent in ['–ü–û–ö–£–ü–ö–ê', '–ö–ê–¢–ê–õ–û–ì', '–ò–ù–§–û–†–ú–ê–¶–ò–Ø', '–ñ–ê–õ–û–ë–ê', '–ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨', '–ü–†–û–ß–ï–ï']:
                return intent

        except Exception as e:
            logger.error(f"Error classifying intent with AI: {str(e)}")
            AI_API_FAILURE_COUNT += 1

    # Fallback to simple classification
    return '–ü–†–û–ß–ï–ï'


def generate_ai_response(session, user_message):
    """Generate AI response with fallback when API fails"""
    global AI_API_FAILURE_COUNT

    # If AI API is not healthy, use fallback immediately
    # if not is_ai_api_healthy():
    #     logger.warning(f"AI API unhealthy, using fallback for {session.sender_id}")
    #     return get_fallback_response(session.current_state, user_message)

    try:
        # Get recent messages for context
        recent_messages = InstaBotMessage.objects.filter(
            sender_id=session.sender_id
        ).order_by('-timestamp')[:MAX_HISTORY_LENGTH]
        recent_messages = list(reversed(recent_messages))

        # Prepare context
        messages = [{"role": "system", "content": get_system_prompt_by_state(session.current_state, session)}]

        # Add product catalog to context
        if session.current_state in ['browsing', 'purchase_product_selection', 'post_purchase']:
            products_context = f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã:\n{format_product_catalog()}"
            messages.append({"role": "system", "content": products_context})

        # Add conversation history
        messages += [{"role": msg.role, "content": msg.content} for msg in recent_messages[-5:]]

        completion = client.chat.completions.create(
            model="google/gemma-3n-e4b-it",
            messages=messages,
            timeout=AI_API_TIMEOUT,
            max_tokens=200
        )

        response = completion.choices[0].message.content

        if response and len(response.strip()) > 0:
            # Success - reset failure count and update last success time
            AI_API_FAILURE_COUNT = 0
            global AI_API_LAST_SUCCESS
            AI_API_LAST_SUCCESS = time.time()
            return response
        else:
            # Empty response - treat as failure
            raise Exception("Empty response from AI API")

    except Exception as e:
        logger.error(f"Error generating AI response for {session.sender_id}: {str(e)}")
        AI_API_FAILURE_COUNT += 1

        # Return fallback response
        return get_fallback_response(session.current_state, user_message)


def send_message(reply, recipient_id):
    """Send message via Instagram Graph API"""

    try:
        url = f'https://graph.instagram.com/v21.0/me/messages'
        headers = {
            'Authorization': f'Bearer {LONG_USER_ACCESS_TOKEN}',
            'Content-Type': "application/json"
        }
        json_body = {
            'recipient': {
                'id': int(recipient_id)
            },
            'message': {
                'text': str(reply)
            }
        }

        response = requests.post(url, headers=headers, json=json_body, timeout=10)
        return response.json()

    except Exception as e:
        logger.error(f"Error sending message to {recipient_id}: {str(e)}")
        return {"error": str(e)}


def process_comment(data):
    """Handle Instagram comment events"""
    print("Comment Event Received:", data)


def process_mention(data):
    """Handle Instagram mention events"""
    print("Mention Event Received:", data)
